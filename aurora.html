<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Aurora Background</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background: #000;
                font-family: Arial, sans-serif;
            }
            canvas {
                display: block;
                width: 100vw;
                height: 100vh;
            }
            .content {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                color: white;
                z-index: 10;
            }
            h1 {
                font-size: 3em;
                margin: 0;
            }
            p {
                font-size: 1.2em;
                margin-top: 1em;
            }
            .error {
                color: #ff6b6b;
                padding: 20px;
                background: rgba(0, 0, 0, 0.8);
                border-radius: 10px;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <div class="content">
            <h1>Aurora Dreams</h1>
            <p>Powered by WebGPU</p>
        </div>

        <script>
            const canvas = document.getElementById("canvas");
            let device, context, pipeline, uniformBuffer;
            let startTime = Date.now();

            const shaderCode = `
            struct Uniforms {
                time: f32,
                resolution: vec2<f32>,
            }
            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            @vertex
            fn vertexMain(@builtin(vertex_index) idx: u32) -> @builtin(position) vec4<f32> {
                var pos = array<vec2<f32>, 6>(
                    vec2<f32>(-1.0, -1.0),
                    vec2<f32>(1.0, -1.0),
                    vec2<f32>(-1.0, 1.0),
                    vec2<f32>(-1.0, 1.0),
                    vec2<f32>(1.0, -1.0),
                    vec2<f32>(1.0, 1.0)
                );
                return vec4<f32>(pos[idx], 0.0, 1.0);
            }

            @fragment
            fn fragmentMain(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
                let uv = pos.xy / uniforms.resolution;
                let t = uniforms.time * 0.3;

                // Create flowing waves
                var p = uv;
                p.y += sin(p.x * 3.0 + t) * 0.1;
                p.x += cos(p.y * 2.0 + t * 0.8) * 0.1;

                // Multiple wave layers for aurora effect
                let wave1 = sin(p.x * 4.0 + t) * sin(p.y * 3.0 + t * 0.7);
                let wave2 = sin(p.x * 6.0 - t * 1.2) * sin(p.y * 5.0 - t * 0.5);
                let wave3 = sin(p.x * 8.0 + t * 0.6) * sin(p.y * 7.0 + t * 0.9);

                // Combine waves
                let combined = (wave1 + wave2 * 0.7 + wave3 * 0.5) * 0.5 + 0.5;

                // Add vertical gradient for aurora shape
                let gradient = smoothstep(0.2, 0.8, uv.y);
                let auroraShape = combined * gradient * (1.0 - gradient * 0.5);

                // Orange to pink color gradient
                let orange = vec3<f32>(1.0, 0.5, 0.2);
                let pink = vec3<f32>(1.0, 0.3, 0.6);
                let purple = vec3<f32>(0.8, 0.2, 0.8);

                // Mix colors based on position and waves
                var color = mix(orange, pink, uv.x);
                color = mix(color, purple, wave2 * 0.3 + 0.2);

                // Apply aurora intensity
                color *= auroraShape * 1.5;

                // Add some glow
                let glow = pow(auroraShape, 2.0) * 0.5;
                color += glow;

                // Dark background blending
                let darkness = vec3<f32>(0.05, 0.02, 0.08);
                color = mix(darkness, color, auroraShape);

                return vec4<f32>(color, 1.0);
            }
        `;

            async function init() {
                if (!navigator.gpu) {
                    document.querySelector(".content").innerHTML =
                        '<div class="error"><h1>WebGPU Not Supported</h1><p>Your browser does not support WebGPU. Try using Chrome or Edge.</p></div>';
                    return;
                }

                const adapter = await navigator.gpu.requestAdapter();
                device = await adapter.requestDevice();

                context = canvas.getContext("webgpu");
                const format = navigator.gpu.getPreferredCanvasFormat();

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                context.configure({
                    device,
                    format,
                    alphaMode: "opaque",
                });

                const shaderModule = device.createShaderModule({
                    code: shaderCode,
                });

                uniformBuffer = device.createBuffer({
                    size: 16,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });

                const bindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        {
                            binding: 0,
                            visibility: GPUShaderStage.FRAGMENT,
                            buffer: { type: "uniform" },
                        },
                    ],
                });

                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        {
                            binding: 0,
                            resource: { buffer: uniformBuffer },
                        },
                    ],
                });

                pipeline = device.createRenderPipeline({
                    layout: device.createPipelineLayout({
                        bindGroupLayouts: [bindGroupLayout],
                    }),
                    vertex: {
                        module: shaderModule,
                        entryPoint: "vertexMain",
                    },
                    fragment: {
                        module: shaderModule,
                        entryPoint: "fragmentMain",
                        targets: [{ format }],
                    },
                    primitive: { topology: "triangle-list" },
                });

                window.addEventListener("resize", () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });

                render(bindGroup);
            }

            function render(bindGroup) {
                const time = (Date.now() - startTime) / 1000;
                const uniformData = new Float32Array([
                    time,
                    0,
                    canvas.width,
                    canvas.height,
                ]);
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [
                        {
                            view: textureView,
                            clearValue: { r: 0.05, g: 0.02, b: 0.08, a: 1 },
                            loadOp: "clear",
                            storeOp: "store",
                        },
                    ],
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.draw(6);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(() => render(bindGroup));
            }

            init();
        </script>
    </body>
</html>
