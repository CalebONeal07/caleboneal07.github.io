<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Animated WebGPU Noise Contours</title>
        <style>
            html,
            body {
                margin: 0;
                background: #111;
                display: flex;
                height: 100%;
                justify-content: center;
                align-items: center;
            }
            canvas {
                width: 100vw;
                height: 100vh;
                filter: blur(0.5px);
            }
        </style>
    </head>
    <body>
        <canvas id="gpu-canvas" width="1" height="1"></canvas>
        <script type="module">
            async function init() {
                if (!navigator.gpu) {
                    alert("WebGPU not supported in this browser.");
                    return;
                }

                const canvas = document.getElementById("gpu-canvas");
                console.log(window.devicePixelRatio);
                console.log(canvas.getBoundingClientRect());
                const rect = canvas.getBoundingClientRect();
                canvas.width = Math.floor(rect.width * window.devicePixelRatio);
                canvas.height = Math.floor(rect.height * window.devicePixelRatio);

                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                const context = canvas.getContext("webgpu");
                const format = navigator.gpu.getPreferredCanvasFormat();
                context.configure({
                    device,
                    format,
                    alphaMode: "premultiplied",
                });

                // Shader with animation support
                const wgsl = `
  struct Uniforms {
      time: f32,
  };
  @group(0) @binding(0) var<uniform> uniforms: Uniforms;

  fn hash(p: vec2<f32>) -> f32 {
      let h = dot(p, vec2<f32>(127.1, 311.7));
      return fract(sin(h) * 43758.5453123);
  }

  fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);

      let a = hash(i);
      let b = hash(i + vec2<f32>(1.0, 0.0));
      let c = hash(i + vec2<f32>(0.0, 1.0));
      let d = hash(i + vec2<f32>(1.0, 1.0));

      let u = f * f * (3.0 - 2.0 * f);

      return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
  }

  @vertex
  fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
      var pos = array<vec2<f32>, 6>(
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0), vec2<f32>(-1.0, 1.0),
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, -1.0), vec2<f32>(1.0, 1.0)
      );
      return vec4<f32>(pos[vid], 0.0, 1.0);
  }

  @fragment
  fn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
      let uv = fragCoord.xy / vec2<f32>(512.0, 512.0);
      let t = uniforms.time * 0.1;

      var n = 0.0;
      var freq = 4.0;
      var amp = 0.5;
      for (var i = 0; i < 5; i++) {
          n += noise(uv * freq + vec2<f32>(t, t * 0.7)) * amp;
          freq *= 2.0;
          amp *= 0.5;
      }
      n = fract(n);

      let contourSpacing = 0.1;
      let lineWidth = 0.015;
      let f = fract(n / contourSpacing);
      let line = step(f, lineWidth) + step(1.0 - f, lineWidth);

      let baseColor = vec3<f32>(0.0, 0.0, 0.0);
      let lineColor = vec3<f32>(0.8875, 0.3417, 0.022);
      let color = mix(baseColor, lineColor, line);
      return vec4<f32>(color, 1.0);
  }
  `;

                const module = device.createShaderModule({ code: wgsl });
                const pipeline = device.createRenderPipeline({
                    layout: "auto",
                    vertex: { module, entryPoint: "vs_main" },
                    fragment: {
                        module,
                        entryPoint: "fs_main",
                        targets: [{ format }],
                    },
                    primitive: { topology: "triangle-list" },
                });

                // Uniform buffer for time
                const uniformBuffer = device.createBuffer({
                    size: 4,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });

                const bindGroup = device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: uniformBuffer } },
                    ],
                });

                let start = performance.now();
                function frame() {
                    const now = performance.now();
                    const time = (now - start) / 1000;
                    device.queue.writeBuffer(
                        uniformBuffer,
                        0,
                        new Float32Array([time]),
                    );

                    const encoder = device.createCommandEncoder();
                    const pass = encoder.beginRenderPass({
                        colorAttachments: [
                            {
                                view: context.getCurrentTexture().createView(),
                                clearValue: { r: 0, g: 0, b: 0, a: 1 },
                                loadOp: "clear",
                                storeOp: "store",
                            },
                        ],
                    });
                    pass.setPipeline(pipeline);
                    pass.setBindGroup(0, bindGroup);
                    pass.draw(6);
                    pass.end();
                    device.queue.submit([encoder.finish()]);

                    requestAnimationFrame(frame);
                }

                frame();
            }

            init();
        </script>
    </body>
</html>
